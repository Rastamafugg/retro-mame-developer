PROCEDURE CALCULATOR
(* Basic09 Scientific Calculator - Phase 1 Week 1 Foundation *)
(* Core Data Structures and Utilities *)

(* ============================================================================ *)
(* PRIORITY 1A: CORE DATA TYPE DEFINITIONS *)
(* ============================================================================ *)

(* Result structure for calculations *)
TYPE calcResult = value: REAL; errorCode: BYTE; valid: BOOLEAN

(* Individual history entry *)
TYPE historyEntry = 
  timeStamp: STRING[19];      (* "yy/mm/dd hh:mm:ss" format *)
  expression: STRING[80];     (* Input expression string *)
  result: calcResult;         (* Calculated result with error info *)
  mode: BYTE                  (* Calculator mode when calculated *)

(* Complete calculator state *)
TYPE calcState =
  currentValue: REAL;         (* Current display value *)
  memoryValue: REAL;          (* Memory storage *)
  lastResult: REAL;           (* Previous calculation result *)
  angleMode: BYTE;            (* 0=RAD, 1=DEG *)
  displayFormat: BYTE;        (* 0=NORMAL, 1=SCI, 2=ENG *)
  decimalPlaces: BYTE;        (* 0-9 decimal places *)
  calcMode: BYTE;             (* 0=BASIC, 1=SCI, 2=STAT, 3=PROG *)
  errorState: BYTE;           (* Current error code *)
  historyCount: INTEGER       (* Number of history entries *)

(* Configuration data structure *)
TYPE configData =
  autoSave: BOOLEAN;          (* Save session on exit *)
  maxHistory: INTEGER;        (* Maximum history entries *)
  backupInterval: INTEGER;    (* Minutes between backups *)
  startupMode: BYTE;          (* Default calculator mode *)
  soundEnabled: BOOLEAN       (* Beep on errors *)

(* ============================================================================ *)
(* GLOBAL ERROR CONSTANTS *)
(* ============================================================================ *)

DIM errNone: BYTE
DIM errDivideZero: BYTE
DIM errOverflow: BYTE
DIM errUnderflow: BYTE
DIM errInvalidFunc: BYTE
DIM errDomainError: BYTE
DIM errSyntaxError: BYTE
DIM errFileError: BYTE
DIM errMemoryFull: BYTE

(* Calculator mode constants *)
DIM modeBasic: BYTE
DIM modeScientific: BYTE
DIM modeStatistical: BYTE
DIM modeProgramming: BYTE

(* Display format constants *)
DIM formatNormal: BYTE
DIM formatScientific: BYTE
DIM formatEngineering: BYTE

(* Angle mode constants *)
DIM angleRadians: BYTE
DIM angleDegrees: BYTE

(* ============================================================================ *)
(* GLOBAL VARIABLE DECLARATIONS *)
(* ============================================================================ *)

(* Main calculator state *)
DIM currentState: calcState

(* Configuration settings *)
DIM config: configData

(* Data arrays *)
DIM history(500): historyEntry      (* Calculation history *)
DIM memoryBanks(10): REAL           (* Multiple memory slots *)
DIM statData(1000): REAL            (* Statistical dataset *)
DIM userConstants(26): REAL         (* A-Z user variables *)
DIM functionKeys(12): STRING[20]    (* F1-F12 definitions *)

(* Working variables *)
DIM tempResult: calcResult
DIM inputBuffer: STRING[80]
DIM errorMessage: STRING[80]

(* ============================================================================ *)
(* MAIN PROGRAM ENTRY POINT *)
(* ============================================================================ *)

(* Initialize system and start main program *)
RUN initCalculator
PRINT "Basic09 Scientific Calculator v1.0 - Foundation Week 1"
PRINT "Initialization completed successfully."
PRINT
RUN testFoundation

END

(* ============================================================================ *)
(* PRIORITY 1A: INITIALIZATION PROCEDURES *)
(* ============================================================================ *)

PROCEDURE initCalculator
(* Initialize all calculator data structures and constants *)

DIM i: INTEGER

(* Initialize error constants *)
errNone := 0
errDivideZero := 1
errOverflow := 2
errUnderflow := 3
errInvalidFunc := 4
errDomainError := 5
errSyntaxError := 6
errFileError := 7
errMemoryFull := 8

(* Initialize mode constants *)
modeBasic := 0
modeScientific := 1
modeStatistical := 2
modeProgramming := 3

(* Initialize display format constants *)
formatNormal := 0
formatScientific := 1
formatEngineering := 2

(* Initialize angle mode constants *)
angleRadians := 0
angleDegrees := 1

(* Initialize calculator state *)
currentState.currentValue := 0.0
currentState.memoryValue := 0.0
currentState.lastResult := 0.0
currentState.angleMode := angleRadians
currentState.displayFormat := formatNormal
currentState.decimalPlaces := 3
currentState.calcMode := modeBasic
currentState.errorState := errNone
currentState.historyCount := 0

(* Initialize configuration *)
config.autoSave := TRUE
config.maxHistory := 500
config.backupInterval := 15
config.startupMode := modeBasic
config.soundEnabled := FALSE

(* Initialize memory banks - use INTEGER loop for efficiency *)
FOR i := 0 TO 9
  memoryBanks(i) := 0.0
NEXT i

(* Initialize user constants A-Z *)
FOR i := 1 TO 26
  userConstants(i) := 0.0
NEXT i

(* Initialize function key definitions *)
functionKeys(1) := "HELP"
functionKeys(2) := "MODE" 
functionKeys(3) := "MEMORY"
functionKeys(4) := "HISTORY"
functionKeys(5) := "EXPORT"
functionKeys(6) := "IMPORT"
functionKeys(7) := "CONFIG"
functionKeys(8) := "CLEAR"
functionKeys(9) := "STAT"
functionKeys(10) := "PROG"
functionKeys(11) := "SAVE"
functionKeys(12) := "EXIT"

(* Initialize history array *)
FOR i := 1 TO 500
  history(i).timeStamp := ""
  history(i).expression := ""
  history(i).result.value := 0.0
  history(i).result.errorCode := errNone
  history(i).result.valid := FALSE
  history(i).mode := modeBasic
NEXT i

(* Initialize statistical data array *)
FOR i := 1 TO 1000
  statData(i) := 0.0
NEXT i

PRINT "Calculator initialization completed."
END

(* ============================================================================ *)
(* PRIORITY 1B: UTILITY PROCEDURES *)
(* ============================================================================ *)

PROCEDURE formatNumber
(* Format a number for display based on current settings *)
PARAM value: REAL; format: BYTE

DIM result: STRING[20]
DIM places: INTEGER

(* Get decimal places from current state *)
places := currentState.decimalPlaces

(* Format based on display format *)
ON format GOTO 100, 200, 300

(* Default to normal format *)
100 (* Normal format *)
    IF places = 0 THEN
      result := STR$(INT(value))
    ELSE
      (* Use PRINT USING equivalent formatting *)
      result := STR$(value)
    ENDIF
    GOTO 400

200 (* Scientific format *)
    result := STR$(value)
    GOTO 400

300 (* Engineering format - simplified *)
    result := STR$(value)
    GOTO 400

400 PRINT result
END

PROCEDURE isValidNumber
(* Validate if a string represents a valid number *)
PARAM testString: STRING[80]

DIM valid: BOOLEAN
DIM testValue: REAL
DIM errorCode: INTEGER

valid := TRUE
errorCode := 0

(* Set up error handling for VAL function *)
ON ERROR GOTO 500

(* Try to convert string to number *)
testValue := VAL(testString)
GOTO 600

(* Error handler - invalid number format *)
500 errorCode := ERR
    valid := FALSE

600 (* Return result by setting global flag *)
    tempResult.valid := valid
    tempResult.errorCode := errorCode
    
END

PROCEDURE stringLength
(* Calculate length of string - Basic09 utility *)
PARAM inputString: STRING[80]

DIM length: INTEGER
DIM i: INTEGER

length := 0
FOR i := 1 TO 80
  IF MID$(inputString, i, 1) = "" THEN
    GOTO 700
  ENDIF
  length := length + 1
NEXT i

700 (* Store result in global for return *)
    (* In full implementation, would use PARAM to return value *)
    PRINT "String length:"; length
END

PROCEDURE clearErrorState
(* Clear calculator error state *)

currentState.errorState := errNone
errorMessage := ""
PRINT "Error state cleared."
END

PROCEDURE setErrorState  
(* Set calculator error state *)
PARAM errorCode: BYTE; message: STRING[80]

currentState.errorState := errorCode
errorMessage := message

(* Display error if sound enabled *)
IF config.soundEnabled THEN
  (* In full OS-9 implementation, could use system beep *)
  PRINT CHR$(7)  (* ASCII bell character *)
ENDIF

PRINT "Error"; errorCode; ": "; message
END

(* ============================================================================ *)
(* BASIC STRING UTILITIES *)
(* ============================================================================ *)

PROCEDURE trimString
(* Remove leading and trailing spaces from string *)
PARAM inputString: STRING[80]

DIM result: STRING[80]
DIM startPos: INTEGER
DIM endPos: INTEGER  
DIM i: INTEGER
DIM length: INTEGER

result := inputString
startPos := 1
endPos := 80
length := 0

(* Find actual string length *)
FOR i := 1 TO 80
  IF MID$(result, i, 1) = "" THEN
    length := i - 1
    GOTO 800
  ENDIF
NEXT i
length := 80

800 (* Find first non-space character *)
    FOR i := 1 TO length
      IF MID$(result, i, 1) <> " " THEN
        startPos := i
        GOTO 810
      ENDIF
    NEXT i
    
810 (* Find last non-space character *)
    FOR i := length TO startPos STEP -1
      IF MID$(result, i, 1) <> " " THEN
        endPos := i
        GOTO 820
      ENDIF
    NEXT i

820 (* Extract trimmed string *)
    IF startPos <= endPos THEN
      result := MID$(result, startPos, endPos - startPos + 1)
    ELSE
      result := ""
    ENDIF
    
    PRINT "Trimmed: '"; result; "'"
END

(* ============================================================================ *)
(* FOUNDATION TESTING PROCEDURE *)
(* ============================================================================ *)

PROCEDURE testFoundation
(* Test all foundation components - Week 1 validation *)

PRINT "=== FOUNDATION TESTING ==="
PRINT

(* Test 1: Data structure initialization *)
PRINT "Test 1: Data Structures"
PRINT "Current value:"; currentState.currentValue
PRINT "Memory value:"; currentState.memoryValue  
PRINT "Calculator mode:"; currentState.calcMode
PRINT "Error state:"; currentState.errorState
PRINT "History count:"; currentState.historyCount
PRINT

(* Test 2: Error constants *)
PRINT "Test 2: Error Constants"
PRINT "No error:"; errNone
PRINT "Divide by zero:"; errDivideZero
PRINT "Overflow:"; errOverflow
PRINT "Invalid function:"; errInvalidFunc
PRINT

(* Test 3: Memory banks *)
PRINT "Test 3: Memory Banks"
memoryBanks(0) := 42.5
memoryBanks(1) := -17.3
PRINT "Bank 0:"; memoryBanks(0)
PRINT "Bank 1:"; memoryBanks(1)
PRINT "Bank 2:"; memoryBanks(2)
PRINT

(* Test 4: Function keys *)
PRINT "Test 4: Function Keys"
PRINT "F1:"; functionKeys(1)
PRINT "F2:"; functionKeys(2)
PRINT "F12:"; functionKeys(12)
PRINT

(* Test 5: Number formatting *)
PRINT "Test 5: Number Formatting"
RUN formatNumber(123.456789, formatNormal)
PRINT

(* Test 6: String validation *)
PRINT "Test 6: String Validation"
RUN isValidNumber("123.45")
PRINT "Valid number result:"; tempResult.valid
RUN isValidNumber("abc")
PRINT "Invalid number result:"; tempResult.valid
PRINT

(* Test 7: Error state management *)
PRINT "Test 7: Error Management"
RUN setErrorState(errDivideZero, "Test error message")
PRINT "Current error state:"; currentState.errorState
RUN clearErrorState
PRINT "After clearing:"; currentState.errorState
PRINT

(* Test 8: String utilities *)
PRINT "Test 8: String Utilities"
RUN trimString("  hello world  ")
PRINT

PRINT "=== FOUNDATION TESTING COMPLETED ==="
PRINT "All Week 1 Priority 1A and 1B components initialized successfully."
END