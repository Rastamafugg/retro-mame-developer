PROCEDURE CALCULATOR
(* Basic09 Scientific Calculator - Phase 1 Week 1 Foundation *)
(* Core Data Structures and Utilities *)

(* ============================================================================ *)
(* PRIORITY 1A: CORE DATA TYPE DEFINITIONS *)
(* ============================================================================ *)

(* Result structure for calculations: value, errorCode, valid *)
TYPE calcResult = value: REAL; errorCode: BYTE; valid: BOOLEAN

(* Individual history entry: timeStamp "yy/mm/dd hh:mm:ss", expression, result, mode *)
TYPE historyEntry = timeStamp: STRING[19]; expression: STRING[80]; result: calcResult; mode: BYTE

(* Calculator state: currentValue, memoryValue, lastResult, angleMode (0=RAD,1=DEG), *)
(* displayFormat (0=NORMAL,1=SCI,2=ENG), decimalPlaces (0-9), calcMode (0=BASIC,1=SCI,2=STAT,3=PROG), *)
(* errorState (current error code), historyCount (number of history entries) *)
TYPE calcState = currentValue: REAL; memoryValue: REAL; lastResult: REAL; angleMode: BYTE; displayFormat: BYTE; decimalPlaces: BYTE; calcMode: BYTE; errorState: BYTE; historyCount: INTEGER

(* Configuration data: autoSave (save on exit), maxHistory (max entries), *)
(* backupInterval (minutes between backups), startupMode (default mode), soundEnabled (beep on errors) *)
TYPE configData = autoSave: BOOLEAN; maxHistory: INTEGER; backupInterval: INTEGER; startupMode: BYTE; soundEnabled: BOOLEAN

(* ============================================================================ *)
(* GLOBAL ERROR CONSTANTS *)
(* ============================================================================ *)

DIM errNone: BYTE
DIM errDivideZero: BYTE
DIM errOverflow: BYTE
DIM errUnderflow: BYTE
DIM errInvalidFunc: BYTE
DIM errDomainError: BYTE
DIM errSyntaxError: BYTE
DIM errFileError: BYTE
DIM errMemoryFull: BYTE

(* Calculator mode constants *)
DIM modeBasic: BYTE
DIM modeScientific: BYTE
DIM modeStatistical: BYTE
DIM modeProgramming: BYTE

(* Display format constants *)
DIM formatNormal: BYTE
DIM formatScientific: BYTE
DIM formatEngineering: BYTE

(* Angle mode constants *)
DIM angleRadians: BYTE
DIM angleDegrees: BYTE

(* ============================================================================ *)
(* GLOBAL VARIABLE DECLARATIONS *)
(* ============================================================================ *)

(* Main calculator state *)
DIM currentState: calcState

(* Configuration settings *)
DIM config: configData

(* Data arrays - these will need to be global for sharing between procedures *)
DIM history(500): historyEntry      (* Calculation history *)
DIM memoryBanks(10): REAL           (* Multiple memory slots *)
DIM statData(1000): REAL            (* Statistical dataset *)
DIM userConstants(26): REAL         (* A-Z user variables *)
DIM functionKeys(12): STRING[20]    (* F1-F12 definitions *)

(* Working variables *)
DIM tempResult: calcResult
DIM inputBuffer: STRING[80]
DIM errorMessage: STRING[80]

(* ============================================================================ *)
(* MAIN PROGRAM ENTRY POINT *)
(* ============================================================================ *)

(* Initialize system and start main program *)
RUN initCalculator(currentState, config, memoryBanks(), userConstants(), functionKeys(), history())
PRINT "Basic09 Scientific Calculator v1.0 - Foundation Week 1"
PRINT "Initialization completed successfully."
PRINT
RUN testFoundation(currentState, config, memoryBanks(), tempResult)

END

(* ============================================================================ *)
(* PRIORITY 1A: INITIALIZATION PROCEDURES *)
(* ============================================================================ *)

PROCEDURE initCalculator
(* Initialize all calculator data structures and constants *)
PARAM state: calcState; conf: configData; memBanks: REAL; userConst: REAL; funcKeys: STRING[20]; hist: historyEntry

(* Re-declare types used in this procedure *)
(* Calculator state: currentValue, memoryValue, lastResult, angleMode (0=RAD,1=DEG), *)
(* displayFormat (0=NORMAL,1=SCI,2=ENG), decimalPlaces (0-9), calcMode (0=BASIC,1=SCI,2=STAT,3=PROG), *)
(* errorState (current error code), historyCount (number of history entries) *)
TYPE calcState = currentValue: REAL; memoryValue: REAL; lastResult: REAL; angleMode: BYTE; displayFormat: BYTE; decimalPlaces: BYTE; calcMode: BYTE; errorState: BYTE; historyCount: INTEGER

(* Configuration data: autoSave (save on exit), maxHistory (max entries), *)
(* backupInterval (minutes between backups), startupMode (default mode), soundEnabled (beep on errors) *)
TYPE configData = autoSave: BOOLEAN; maxHistory: INTEGER; backupInterval: INTEGER; startupMode: BYTE; soundEnabled: BOOLEAN

(* Result structure for calculations: value, errorCode, valid *)
TYPE calcResult = value: REAL; errorCode: BYTE; valid: BOOLEAN

(* Individual history entry: timeStamp "yy/mm/dd hh:mm:ss", expression, result, mode *)
TYPE historyEntry = timeStamp: STRING[19]; expression: STRING[80]; result: calcResult; mode: BYTE

DIM i: INTEGER

(* Error constants - local to this procedure *)
DIM errNone: BYTE
DIM errDivideZero: BYTE  
DIM errOverflow: BYTE
DIM errUnderflow: BYTE
DIM errInvalidFunc: BYTE
DIM errDomainError: BYTE
DIM errSyntaxError: BYTE
DIM errFileError: BYTE
DIM errMemoryFull: BYTE

(* Mode constants - local to this procedure *)
DIM modeBasic: BYTE
DIM modeScientific: BYTE
DIM modeStatistical: BYTE
DIM modeProgramming: BYTE

(* Display format constants - local to this procedure *)
DIM formatNormal: BYTE
DIM formatScientific: BYTE
DIM formatEngineering: BYTE

(* Angle mode constants - local to this procedure *)
DIM angleRadians: BYTE
DIM angleDegrees: BYTE

(* Initialize error constants *)
errNone := 0
errDivideZero := 1
errOverflow := 2
errUnderflow := 3
errInvalidFunc := 4
errDomainError := 5
errSyntaxError := 6
errFileError := 7
errMemoryFull := 8

(* Initialize mode constants *)
modeBasic := 0
modeScientific := 1
modeStatistical := 2
modeProgramming := 3

(* Initialize display format constants *)
formatNormal := 0
formatScientific := 1
formatEngineering := 2

(* Initialize angle mode constants *)
angleRadians := 0
angleDegrees := 1

(* Initialize calculator state *)
state.currentValue := 0.0
state.memoryValue := 0.0
state.lastResult := 0.0
state.angleMode := angleRadians
state.displayFormat := formatNormal
state.decimalPlaces := 3
state.calcMode := modeBasic
state.errorState := errNone
state.historyCount := 0

(* Initialize configuration *)
conf.autoSave := TRUE
conf.maxHistory := 500
conf.backupInterval := 15
conf.startupMode := modeBasic
conf.soundEnabled := FALSE

(* Initialize memory banks - use INTEGER loop for efficiency *)
FOR i := 0 TO 9
  memBanks(i) := 0.0
NEXT i

(* Initialize user constants A-Z *)
FOR i := 1 TO 26
  userConst(i) := 0.0
NEXT i

(* Initialize function key definitions *)
funcKeys(1) := "HELP"
funcKeys(2) := "MODE" 
funcKeys(3) := "MEMORY"
funcKeys(4) := "HISTORY"
funcKeys(5) := "EXPORT"
funcKeys(6) := "IMPORT"
funcKeys(7) := "CONFIG"
funcKeys(8) := "CLEAR"
funcKeys(9) := "STAT"
funcKeys(10) := "PROG"
funcKeys(11) := "SAVE"
funcKeys(12) := "EXIT"

(* Initialize history array *)
DIM tempHist: historyEntry
tempHist.timeStamp := ""
tempHist.expression := ""
tempHist.result.value := 0.0
tempHist.result.errorCode := errNone
tempHist.result.valid := FALSE
tempHist.mode := modeBasic

FOR i := 1 TO 500
  hist(i) := tempHist
NEXT i

PRINT "Calculator initialization completed."
END

(* ============================================================================ *)
(* PRIORITY 1B: UTILITY PROCEDURES *)
(* ============================================================================ *)

PROCEDURE formatNumber
(* Format a number for display based on current settings *)
PARAM value: REAL; format: BYTE; places: INTEGER

DIM result: STRING[20]

(* Format based on display format *)
ON format GOTO 100, 200, 300

(* Default to normal format *)
100 (* Normal format *)
    IF places = 0 THEN
      result := STR$(INT(value))
    ELSE
      (* Use PRINT USING equivalent formatting *)
      result := STR$(value)
    ENDIF
    GOTO 400

200 (* Scientific format *)
    result := STR$(value)
    GOTO 400

300 (* Engineering format - simplified *)
    result := STR$(value)
    GOTO 400

400 PRINT result
END

PROCEDURE isValidNumber
(* Validate if a string represents a valid number *)
PARAM testString: STRING[80]; result: calcResult

(* Re-declare type used in this procedure *)
(* Result structure for calculations: value, errorCode, valid *)
TYPE calcResult = value: REAL; errorCode: BYTE; valid: BOOLEAN

DIM valid: BOOLEAN
DIM testValue: REAL
DIM errorCode: INTEGER

valid := TRUE
errorCode := 0

(* Set up error handling for VAL function *)
ON ERROR GOTO 500

(* Try to convert string to number *)
testValue := VAL(testString)
GOTO 600

(* Error handler - invalid number format *)
500 errorCode := ERR
    valid := FALSE

600 (* Set result values *)
    result.valid := valid
    result.errorCode := errorCode
    result.value := testValue
    
END

PROCEDURE stringLength
(* Calculate length of string - Basic09 utility *)
PARAM inputString: STRING[80]; length: INTEGER

DIM i: INTEGER

length := 0
FOR i := 1 TO 80
  IF MID$(inputString, i, 1) = "" THEN
    GOTO 700
  ENDIF
  length := length + 1
NEXT i

700 (* Length calculated and returned via parameter *)
END

PROCEDURE clearErrorState
(* Clear calculator error state *)
PARAM state: calcState

(* Re-declare type used in this procedure *)
(* Calculator state: currentValue, memoryValue, lastResult, angleMode (0=RAD,1=DEG), *)
(* displayFormat (0=NORMAL,1=SCI,2=ENG), decimalPlaces (0-9), calcMode (0=BASIC,1=SCI,2=STAT,3=PROG), *)
(* errorState (current error code), historyCount (number of history entries) *)
TYPE calcState = currentValue: REAL; memoryValue: REAL; lastResult: REAL; angleMode: BYTE; displayFormat: BYTE; decimalPlaces: BYTE; calcMode: BYTE; errorState: BYTE; historyCount: INTEGER

DIM errNone: BYTE
errNone := 0

state.errorState := errNone
PRINT "Error state cleared."
END

PROCEDURE setErrorState  
(* Set calculator error state *)
PARAM state: calcState; errorCode: BYTE; message: STRING[80]; soundEnabled: BOOLEAN

(* Re-declare type used in this procedure *)
(* Calculator state: currentValue, memoryValue, lastResult, angleMode (0=RAD,1=DEG), *)
(* displayFormat (0=NORMAL,1=SCI,2=ENG), decimalPlaces (0-9), calcMode (0=BASIC,1=SCI,2=STAT,3=PROG), *)
(* errorState (current error code), historyCount (number of history entries) *)
TYPE calcState = currentValue: REAL; memoryValue: REAL; lastResult: REAL; angleMode: BYTE; displayFormat: BYTE; decimalPlaces: BYTE; calcMode: BYTE; errorState: BYTE; historyCount: INTEGER

state.errorState := errorCode

(* Display error if sound enabled *)
IF soundEnabled THEN
  (* In full OS-9 implementation, could use system beep *)
  PRINT CHR$(7)  (* ASCII bell character *)
ENDIF

PRINT "Error"; errorCode; ": "; message
END

(* ============================================================================ *)
(* BASIC STRING UTILITIES *)
(* ============================================================================ *)

PROCEDURE trimString
(* Remove leading and trailing spaces from string *)
PARAM inputString: STRING[80]; result: STRING[80]

DIM startPos: INTEGER
DIM endPos: INTEGER  
DIM i: INTEGER
DIM length: INTEGER

result := inputString
startPos := 1
endPos := 80
length := 0

(* Find actual string length *)
FOR i := 1 TO 80
  IF MID$(result, i, 1) = "" THEN
    length := i - 1
    GOTO 800
  ENDIF
NEXT i
length := 80

800 (* Find first non-space character *)
    FOR i := 1 TO length
      IF MID$(result, i, 1) <> " " THEN
        startPos := i
        GOTO 810
      ENDIF
    NEXT i
    
810 (* Find last non-space character *)
    FOR i := length TO startPos STEP -1
      IF MID$(result, i, 1) <> " " THEN
        endPos := i
        GOTO 820
      ENDIF
    NEXT i

820 (* Extract trimmed string *)
    IF startPos <= endPos THEN
      result := MID$(result, startPos, endPos - startPos + 1)
    ELSE
      result := ""
    ENDIF
END

(* ============================================================================ *)
(* FOUNDATION TESTING PROCEDURE *)
(* ============================================================================ *)

PROCEDURE testFoundation
(* Test all foundation components - Week 1 validation *)
PARAM state: calcState; conf: configData; memBanks: REAL; tempRes: calcResult

(* Re-declare types used in this procedure *)
(* Calculator state: currentValue, memoryValue, lastResult, angleMode (0=RAD,1=DEG), *)
(* displayFormat (0=NORMAL,1=SCI,2=ENG), decimalPlaces (0-9), calcMode (0=BASIC,1=SCI,2=STAT,3=PROG), *)
(* errorState (current error code), historyCount (number of history entries) *)
TYPE calcState = currentValue: REAL; memoryValue: REAL; lastResult: REAL; angleMode: BYTE; displayFormat: BYTE; decimalPlaces: BYTE; calcMode: BYTE; errorState: BYTE; historyCount: INTEGER

(* Configuration data: autoSave (save on exit), maxHistory (max entries), *)
(* backupInterval (minutes between backups), startupMode (default mode), soundEnabled (beep on errors) *)
TYPE configData = autoSave: BOOLEAN; maxHistory: INTEGER; backupInterval: INTEGER; startupMode: BYTE; soundEnabled: BOOLEAN

(* Result structure for calculations: value, errorCode, valid *)
TYPE calcResult = value: REAL; errorCode: BYTE; valid: BOOLEAN

DIM testResult: STRING[80]
DIM testLength: INTEGER
DIM errDivideZero: BYTE

errDivideZero := 1

PRINT "=== FOUNDATION TESTING ==="
PRINT

(* Test 1: Data structure initialization *)
PRINT "Test 1: Data Structures"
PRINT "Current value:"; state.currentValue
PRINT "Memory value:"; state.memoryValue  
PRINT "Calculator mode:"; state.calcMode
PRINT "Error state:"; state.errorState
PRINT "History count:"; state.historyCount
PRINT

(* Test 2: Configuration data *)
PRINT "Test 2: Configuration"
PRINT "Auto save:"; conf.autoSave
PRINT "Max history:"; conf.maxHistory
PRINT "Backup interval:"; conf.backupInterval
PRINT "Sound enabled:"; conf.soundEnabled
PRINT

(* Test 3: Memory banks *)
PRINT "Test 3: Memory Banks"
memBanks(0) := 42.5
memBanks(1) := -17.3
PRINT "Bank 0:"; memBanks(0)
PRINT "Bank 1:"; memBanks(1)
PRINT "Bank 2:"; memBanks(2)
PRINT

(* Test 4: Number formatting *)
PRINT "Test 4: Number Formatting"
RUN formatNumber(123.456789, 0, 3)
PRINT

(* Test 5: String validation *)
PRINT "Test 5: String Validation"
RUN isValidNumber("123.45", tempRes)
PRINT "Valid number result:"; tempRes.valid
RUN isValidNumber("abc", tempRes)
PRINT "Invalid number result:"; tempRes.valid
PRINT

(* Test 6: Error state management *)
PRINT "Test 6: Error Management"
RUN setErrorState(state, errDivideZero, "Test error message", FALSE)
PRINT "Current error state:"; state.errorState
RUN clearErrorState(state)
PRINT "After clearing:"; state.errorState
PRINT

(* Test 7: String utilities *)
PRINT "Test 7: String Utilities"
RUN stringLength("Hello World", testLength)
PRINT "String length:"; testLength
RUN trimString("  hello world  ", testResult)
PRINT "Trimmed: '"; testResult; "'"
PRINT

PRINT "=== FOUNDATION TESTING COMPLETED ==="
PRINT "All Week 1 Priority 1A and 1B components initialized successfully."
END